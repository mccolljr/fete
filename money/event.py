from __future__ import annotations
from typing import Any, Callable, Dict, Generic, Tuple, Type, TypeVar, Union, overload

from money.schema import SchemaBase, SchemaMeta


TEvt = TypeVar("TEvt", bound="EventBase", contravariant=True)

EventHandlerFunction = Callable[[Any, TEvt], None]
EventHandlerDecorator = Callable[[EventHandlerFunction[TEvt]], "EventHandler[TEvt]"]


class EventMeta(SchemaMeta):
    """The metaclass that all event classes must inherit from."""

    __by_name: Dict[str, EventMeta] = {}

    def __new__(cls, name: str, bases: Tuple[type, ...], attrs: Dict[str, Any]):
        if name in cls.__by_name:
            raise TypeError(f"duplicate definition for event {name}")
        new_class = super().__new__(cls, name, bases, attrs)
        cls.__by_name[name] = new_class
        return new_class

    @classmethod
    def construct_named(cls, name: str, args: Dict[str, Any]) -> EventBase:
        return cls.__by_name[name](**args)


class EventBase(SchemaBase, metaclass=EventMeta):
    """The base that all event classes must inherit from."""


def handle_event(evt_class: Type[TEvt]) -> EventHandlerDecorator[TEvt]:
    """A decorator to apply to aggregate methods which handle certain events."""

    def event_handler_decorator(handler: EventHandlerFunction[TEvt]):
        return EventHandler(handler, evt_class)

    return event_handler_decorator


class EventHandler(Generic[TEvt]):
    """
    A descriptor for an event handler method, generated by a call to `handle_event`
    """

    _evt_class: Type[TEvt]

    def __init__(self, handler: EventHandlerFunction[TEvt], evt_class: Type[TEvt]):
        self.__dict__["_handler"] = handler
        self._evt_class = evt_class

    def __set_name__(self, owner: Any, name: str):
        owner.__agg_events__[self._evt_class] = name

    @overload
    def __get__(self, obj: None, objtype: Any) -> "EventHandler[TEvt]":
        ...

    @overload
    def __get__(self, obj: Any, objtype: Any) -> Callable[[TEvt], None]:
        ...

    def __get__(
        self, obj: Any, objtype=None
    ) -> Union["EventHandler[TEvt]", Callable[[TEvt], None]]:
        if obj is None:
            return self
        return lambda evt: self.__dict__["_handler"](obj, evt)
